import #prelude

const starting-tape [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1
]

func fmtTape [Int] {
    ;; [tape]
    dup ;; [tape tape]
    len ;; [i tape]
    take tape' len' { ;; pop i -> len', pop tape -> tape'
        0 while dup len' < {
            ;; [i]
            tape' ;; [tape i]
            swap  ;; [i tape]
            dup   ;; [i i tape]
            rot   ;; [i tape i]
            @     ;; [idx i]
            1 =   ;; [bool i]
            if { "â–ˆ" } else { " " } ;; [string i]
            puts  ;; [i]
            1 +   ;; [i]
        } drop
    }
}

func nextTape [Int] -- [Int] {
    dup len
    [] store(result)
    take tape' len' {
        0 while dup len' < {
            ;; [i]
            dup ;; [i* i]
            1 - ;; [i* i]
            dup ;; [i* i* i]
            0 < ;; [bool i]
            if { drop len' 1 - } else { } ;; [i* i]
            store(a) ;; [i], pop i* -> a

            dup      ;; [i* i]
            store(b) ;; [i], pop i* -> b

            dup   ;; [i* i]
            1 +   ;; [i* i]
            dup   ;; [i* i* i]
            len'  ;; [len i* i* i]
            1 - > ;; [bool i* i]
            if { drop 0 } else { } ;; [i* i]
            store(c)        ;; [i], pop i* -> c
            tape' load(c) @ ;; [c i]
            tape' load(b) @ ;; [b c i]
            tape' load(a) @ ;; [a b c i]
            3 .*            ;; [[a b c] i]
            2 store(r)
            dup [1, 1, 1] = if { 0 store(r) } else { }
            dup [1, 1, 0] = if { 1 store(r) } else { }
            dup [1, 0, 1] = if { 1 store(r) } else { }
            dup [1, 0, 0] = if { 0 store(r) } else { }
            dup [0, 1, 1] = if { 1 store(r) } else { }
            dup [0, 1, 0] = if { 1 store(r) } else { }
            dup [0, 0, 1] = if { 1 store(r) } else { }
            dup [0, 0, 0] = if { 0 store(r) } else { }
            drop
            load(r)
            ;; [i* i]
            dup 1 > if { drop 0 } else { } ;; clamp
            1 .*          ;; [[i*] i]
            load(result)  ;; [[r..] [i*] i]
            //            ;; [[i* : r ] i]
            store(result) ;; [i], pop [i* : r] -> resulta
            1 +
        } drop
    }
    load(result)
}

entry {
    starting-tape  store(tape)
    load(tape) len store(amount)
    load(tape) fmtTape
    0 while dup load(amount) < {
        "" putsln
        load(tape) nextTape store(tape)
        load(tape) fmtTape
        1 +
    }
}